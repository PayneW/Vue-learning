- 我们为什么需要异步？
    + 最根本的原因在于对不同硬件访问速度上的差异。
    + 差异从高到低依次为:
        - 寄存器
        - L1 高速缓存
        - L2 高速缓存
        - L3 高速缓存
        - 内存
        - 硬盘
        - Web 服务器

- 单线程的 JavaScript 如何实现异步？
    + 虽然解释和执行 js 代码的线程只有一个，
    + 但是浏览器内部还有"其他线程来专门负责异步任务的"。比如定时器、UI、事件、网络之类专门的线程来负责相关任务的处理。



```
    - micro  /'maikrəu/ pref. 前缀: 表示"极微小" 之义。
    - macro  /'mækrəʊ/  n. 宏.  adj. 巨大的
        + --> the analysis of social events at the macro level. 从宏观层面对社会事件的分析。
    - immediate  /ɪ'miːdɪət/  adj. 即时，立刻，立即的.
        + --> in the immediate future. 在不远的将来
        + --> immediate destination. 直接目的地

    - mutation  /mjuː'teɪʃ(ə)n/  n. 突变，变动
    - idle  /'aɪd(ə)l/  adj. 空闲，懒惰，闲置的.  vt. 虚度.  vi. 空转
        + --> idle hands. 闲置着的人手。
        + --> Don't idle about. 不要游手好闲。
```


- 实现的逻辑 (event loop)
    + JS 主线程会维护一个执行栈，然后逐行执行代码。
    + 如果碰到异步代码 (比如 Promise、then、AJAX、setTimeout 等等)，那么他会把这些代码交给浏览器的其他相关的线程
    去执行，然后跳过这些代码继续往下执行，直到当前代码段结束。
    + 同时浏览器的其他相关线程处理好该异步代码执行前需要的准备工作时 (比如说 AJAX 数据，鼠标事件等触发，定时器的时间到
    了等)，浏览器会把当前的异步代码放入一个异步任务队列中 (queue 先进先出)。
    + 每当主线程逐行执行完当前代码时，都会去检查异步队列中是否有任务需要执行，如果有，那么就把那个任务拿出来再逐行执行，
    如果在其中又碰到了异步代码，那么在家给浏览器的其他线程去处理，然后跳过这些代码继续执行，直到当前代码段结束，
    + 然后检查异步队列，如此循环往复...... 所以叫事件循环。
- 异步队列 Microtask 和 Macrotask
    + 异步队列并非只有一个，主要分为 Microtask(微任务)队列 和  Macrotask(宏任务)队列。
    + Microtask: process.nextTick, Promise, Object.observe, MutationObserver
    + Macrotask: setTimeout, setInterval, setImmediate, I/0, MessageChannel, postMessage, UI渲染，<script>中的 js 代码
    + 两个队列依次执行，但是有一个重要的区别:
        - 1.当前 MicroTask 队列中的任务会被全部执行完。
        - 2.当前 Macrotask 队列中的任务只会挑队列中一个最先的任务执行，然后就跳到 Microtask

- 任务的优先级 (来自 《深入浅出 Node.js》)
    + idle 观察者 > I/0 观察者 > check 观察者
    + process.nextTick (idle)  >  Promise (原生实现)
    + setTimeout (I/O)  >  setImmediate (check)
    + 这个不会太绝对，会有差异，如果时间为 0， 基本符合这个结果



#### 示例讲解
```js
    setImmediate(() => { console.log(1) }, 0)
    setTimeout(() => { console.log(2) }, 0)
    new Promise((resolve) => {
        console.log(3);
        resolve();
        console.log(4);
    }).then(() => { console.log(5); })
    console.log(6);
    process.nextTick(() => { console.log(7); })
    console.log(8);

    // 输出顺序为: 3 4 6 8 7 5 2 1
```
